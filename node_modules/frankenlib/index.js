// Copyright 2017 by Frank Trampe

function str_pad(val, pad_char, pad_length) {
	// This is from Frank.
	var op1 = val.toString();
	while (op1.length < pad_length) {
		op1 = pad_char + op1;
	}
	return op1;
}

function email_domain(address) {
	// This is from Frank.
	if (typeof(address) != "string") return null;
	var domr = address.match(/\@([A-Za-z0-9_\.-]+)$/);
	if (domr != null && domr.length > 1) return domr[1];
	return null;
}

function email_domains(addresses) {
	// This deduplicates and may not preserve order.
	var domain_lookup = {};
	addresses.forEach(function (address) {
		var td = email_domain(address);
		if (td) domain_lookup[td] = 1;
	});
	var domain_list = [];
	if (1) {
		var td;
		for (td in domain_lookup) {
			domain_list.push(td);
		}
	}
	return domain_list;
}

function uri_split(uri) {
	// This is from Frank.
	var pieces = uri.match(/^([A-Za-z0-9]+):\/\/([A-Za-z0-9.-]+)(:([0-9]+))?(\/([A-Za-z0-9_+%&$=/.-]*)(\?([A-Za-z0-9_+%&$=/.-]*))?)?/);
	if (pieces)
		return {protocol: pieces[1], host: pieces[2], port: pieces[4], fullHost: pieces[2] + (pieces[3] || ""), path: pieces[6], query: pieces[8]};
	return null;
}

function array_to_dict(array_data, key_name) {
	// This is from Frank.
	if (!array_data) return null;
	var dict_data = {};
	array_data.forEach(function (array_item) {
		if (key_name in array_item)
			dict_data[array_item[key_name]] = array_item;
	});
	return dict_data;
}

function array_to_dict_by_function(array_data, key_function) {
	// This is from Frank.
	if (!array_data) return null;
	var dict_data = {};
	array_data.forEach(function (array_item) {
		var key = key_function(array_item);
		if (key != null)
			dict_data[key] = array_item;
	});
	return dict_data;
}

function dict_to_array(dict_data, key_name, ordering_override) {
	// This is from Frank.
	if (!dict_data) return null;
	var array_data = [];
	var ordering = Object.keys(dict_data);
	if (ordering_override instanceof Array)
		ordering = ordering_override
	ordering.forEach(function (item_key) {
		if (!key_name || key_name in dict_data[item_key] && dict_data[item_key][key_name] == item_key)
			array_data.push(dict_data[item_key]);
	});
	return array_data;
}

function check_path_in_dict(dict, d_path) {
	// This is from Frank.
	var t_node = dict;
	var r_flag = true;
	d_path.forEach(function (t_name) {
		if (!(t_node instanceof Object))
			return r_flag = false;
		if (t_node == null || !(t_name in t_node))
			return r_flag = false;
		t_node = t_node[t_name];
		return true;
	});
	return r_flag;
}

function create_path_in_dict(dict, d_path) {
	// This is from Frank.
	var t_node = dict;
	d_path.forEach(function (t_name) {
		if (!(t_name in t_node))
			t_node[t_name] = {};
		t_node = t_node[t_name];
	});
	return null;
}

function dict_sort(dict, comp) {
	var sortIndex = Object.keys(dict).sort(comp);
	var op = {};
	sortIndex.forEach(function (tn) {
		op[tn] = dict[tn];
	});
	return op;
}

function make_query_string(exso) {
	var ruri = "";
	if (exso) {
		for (pname in exso) {
			if (typeof(exso[pname]) == 'string' || typeof(exso[pname]) == 'number')
				ruri += (ruri.length ? "&" : "") + pname + "=" + encodeURIComponent(exso[pname]);
			else if (typeof(exso[pname]) == 'object' && exso[pname] instanceof Array)
				exso[pname].forEach(function (sval) {
					if (typeof(sval) == 'string' || typeof(sval) == 'number')
						ruri += (ruri.length ? "&" : "") + pname + "=" + encodeURIComponent(sval);
				});
		}
	}
	return ruri;
}

function divide_array(flat_array, division_size) {
	var slices_array = [];
	while (slices_array.length * division_size < flat_array.length) {
		slices_array.push(flat_array.slice(slices_array.length * division_size,
			Math.min(flat_array.length, (slices_array.length + 1) * division_size)));
	}
	return slices_array;
}

function undivide_array(slices_array) {
	var flat_array = [];
	slices_array.forEach(function (current_slice) {
		flat_array = flat_array.concat(current_slice);
	});
	return flat_array;
}

function object_copy_flat(original) {
	// This is from Frank.
	var duplicate = {};
	var tkey;
	for (tkey in original) {
		duplicate[tkey] = original[tkey];
	}
	return duplicate;
}

function bin_dict_by_key(flat_data, field_name) {
	// This is from Frank.
	var binned_data = {};
	var item_key;
	for (item_key in flat_data) {
		if (field_name in flat_data[item_key] && flat_data[item_key][field_name] != undefined) {
			create_path_in_dict(binned_data, [flat_data[item_key][field_name]]);
			binned_data[flat_data[item_key][field_name]][item_key] = flat_data[item_key];
		}
	}
	return binned_data;
}

function unbin_dict(binned_data) {
	// This is from Frank.
	var flat_data = {};
	var bin_key;
	var item_key;
	for (bin_key in binned_data)
		for (item_key in binned_data[bin_key])
			flat_data[item_key] = binned_data[bin_key][item_key];
	return flat_data;
}

function unbin_dict_with_key(binned_data, key_name) {
	// This is from Frank.
	var flat_data = {};
	var bin_key;
	var item_key;
	for (bin_key in binned_data)
		for (item_key in binned_data[bin_key])
			if (binned_data[bin_key][item_key] instanceof Object &&
					key_name in binned_data[bin_key][item_key] && binned_data[bin_key][item_key][key_name] != undefined)
				flat_data[binned_data[bin_key][item_key][key_name]] = binned_data[bin_key][item_key];
	return flat_data;
}

function dict_rekey(ind, kn) {
	var nd = {};
	var tname;
	for (tname in ind)
		if (kn in ind[tname] && ind[tname][kn] != undefined)
			nd[ind[tname][kn]] = ind[tname];
	return nd;
}

function convert_dict_to_numeric(input) {
	var output = {};
	var fname;
	for (fname in input)
		if (input[fname] !== null && !isNaN(input[fname]))
			output[fname] = Number(input[fname]);
	return output;
}

function match_length_wrapper(res) {
	if (res) return res.length;
	return 0;
}

function type_number_or_string_not_blank(val) {
	if ((typeof(val) == 'string' && val.length > 0) || typeof(val) == 'number')
		return 1;
	return 0;
}

function type_string_not_blank(val) {
	if (typeof(val) == 'string' && val.length > 0)
		return 1;
	return 0;
}

function date_to_YMD_dash(tdate) {
	return tdate.getUTCFullYear() + "-" + tdate.getUTCMonth() + "-" + tdate.getUTCDate();
}

module.exports = exports = {str_pad, email_domain, email_domains, uri_split, array_to_dict, array_to_dict_by_function, dict_to_array, check_path_in_dict, dict_sort, make_query_string, divide_array, undivide_array, object_copy_flat, bin_dict_by_key, unbin_dict, unbin_dict_with_key, dict_rekey, match_length_wrapper, type_number_or_string_not_blank, type_string_not_blank, create_path_in_dict};

