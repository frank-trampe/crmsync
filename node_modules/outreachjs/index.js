// Copyright 2017 by Frank Trampe
// This interfaces with services provided by outreach.io.
const frankenlib = require("frankenlib");
const requestp = require("request-promise-native");
function errPass(err) { return Promise.reject(err); }

function emailDomain(address) {
	return frankenlib.email_domain(address);
}

function arrayToDict(arrayData, keyName) {
	return frankenlib.array_to_dict(arrayData, keyName);
}

function dictToArray(dictData, keyName) {
	return frankenlib.dict_to_array(dictData, keyName);
}

function checkPathInDict(dict, dPath) {
	return frankenlib.check_path_in_dict(dict, dPath);
}

function makeQueryString(exso) {
	return frankenlib.make_query_string(exso);
}

function divideArray(flatArray, divisionSize) {
	return frankenlib.divide_array(flatArray, divisionSize);
}

function undivideArray(slicesArray) {
	return frankenlib.undivide_array(slicesArray);
}

function dateConvertToOutreachUTC(inDate) {
	return frankenlib.str_pad(inDate.getUTCFullYear(), "0", 4) + "-" + frankenlib.str_pad(inDate.getUTCMonth(), "0", 2) + "-" +
		frankenlib.str_pad(inDate.getUTCDay(), "0", 2) + "T" + frankenlib.str_pad(inDate.getUTCHours(), "0", 2) +
		":" + frankenlib.str_pad(inDate.getUTCMinutes(), "0", 2);
}

function outreachProspectV1ExtractAddress(outreachContact) {
	var res = outreachContact;
	if (res && checkPathInDict(res, ['attributes', 'contact', 'email']) &&
			typeof(res.attributes.contact.email) == 'string' && res.attributes.contact.email.length > 0)
		return res.attributes.contact.email;
	return null;
}

function outreachProspectsV1ExtractAddresses(outreachContacts) {
	var emailLookup = {};
	outreachContacts.forEach(function (res, res_i) {
		var te = outreachProspectV1ExtractAddress(res);
		if (te) emailLookup[te] = te;
	});
	var emailList = dictToArray(emailLookup);
	return emailList;
}

// This is what runs on each import to Outreach.
// https://api.outreach.io/1.0/prospects?filter[metadata/updated/after]=yyyy-MM-ddTHH:mm

function outreachRecordsGet(basePath, queryParams, headers, baseData, offset) {
// headers: {"Authorization": "Bearer <Access_Token>", "Content-Type": "application/vnd.api+json"}
	// This works in singular mode if baseData is null or undefined.
	var standardPageLimit = 100;
	var dataName = 'data';
	var qps2 = {};
	for (qp in queryParams) qps2[qp] = queryParams[qp];
	if (offset != null && offset != undefined) qps2['page[offset]'] = offset;
	qps2['page[limit]'] = standardPageLimit;
	var hs2 = {};
	for (hp in headers) hs2[hp] = headers[hp];
	var queryParamsString = makeQueryString(qps2);
	var qe = {
		uri: basePath + (queryParamsString.length ? "?" : "") + queryParamsString,
		method: "GET",
		simple: true,
		headers: hs2,
		/* jar: cookie_jar, */
		encoding: null,
		resolveWithFullResponse: false /* Change to true to have the promise return the full response. */
	};
	// console.log(qe);
	return requestp(qe).then(function (rd) {
		// console.log(rd);
		var qres = null;
		try {
			var rds = rd.toString("utf8");
			qres = JSON.parse(rds);
		} catch (rdpe) {
			return Promise.reject(rdpe);
		}
		if (dataName in qres && qres[dataName] instanceof Array) {
			baseData = baseData.concat(qres[dataName]);
			// Check response size against limit to see about getting another page.
			if (qres[dataName].length == standardPageLimit)
				return getOutreachRecords(basePath, queryParams, headers, baseData, offset + standardPageLimit);
		} else if ((baseData == null || baseData == undefined) && dataName in qres) {
			return qres[dataName];
		}
		return baseData;
	}, errPass);
}

function outreachRecordPatch(basePath, queryParams, headers, data) {
	var dataName = 'data';
	var qps2 = {};
	for (qp in queryParams) qps2[qp] = queryParams[qp];
	var hs2 = {};
	for (hp in headers) hs2[hp] = headers[hp];
	var queryParamsString = makeQueryString(qps2);
	var rpe = {
		uri: basePath + (queryParamsString.length ? "?" : "") + queryParamsString,
		method: "PATCH",
		simple: true,
		headers: hs2,
		json: true,
		body: data,
		/* jar: cookie_jar, */
		encoding: null,
		resolveWithFullResponse: false /* Change to true to have the promise return the full response. */
	};
	// console.log(rpe);
	return requestp(rpe).then(function (rd) {
		var qres = rd;
		if (dataName in qres) {
			return qres[dataName];
		}
		if ("errors" in qres) {
			var rerr = new Error("Outreach query problem.");
			rerr.details = {errors: qres.errors, request: rpe};
			return Promise.reject(rerr);
		}
		return qres;
	}, errPass);
}

var sample_outreach_token = {
  "access_token": "<Access_Token>",
  "token_type": "bearer",
  "expires_in": 7200,
  "refresh_token": "<Refresh_Token>",
  "scope": "<Scope1+Scope2+Scope3>",
  "created_at": 1503308300
};

function outreachHeadersAppendToken(headers, token) {
	if (typeof(token) == 'object' && 'access_token' in token &&
			typeof(token.access_token) == 'string') {
		headers['Authorization'] = "Bearer " + token.access_token;
	}
	headers['Content-Type'] = "application/vnd.api+json";
	return headers;
}

function outreachRecordsGetAllWithToken(basePath, queryParams, token) {
	var headers = {};
	outreachHeadersAppendToken(headers, token);
	return outreachRecordsGet(basePath, queryParams, headers, [], null);
}

function outreachTokenCheckValid(token, timeOffset) {
	var nowDate = new Date();
	if ('created_at' in token && 'expires_in' in token &&
			typeof(token.created_at) == 'number' &&
			typeof(token.expires_in) == 'number' &&
			(token.created_at + token.expires_in) * 1000 + timeOffset > nowDate.valueOf())
		return true;
	return false;
}

function outreachTokenRefresh(application, token) {
	return requestp({
			uri: "https://api.outreach.io/oauth/token",
			method: "POST",
			simple: true,
			form: {
				client_id: application.client_id,
				client_secret: application.client_secret,
				redirect_uri: application.redirect_uri,
				grant_type: "refresh_token",
				refresh_token: token.refresh_token
			},
			/* jar: cookie_jar, */
			encoding: null,
			resolveWithFullResponse: false /* Change to true to have the promise return the full response. */
	}).then(function (rd) {
		var qres = null;
		try {
			var rds = rd.toString("utf8");
			qres = JSON.parse(rds);
		} catch (rdpe) {
			return Promise.reject(rdpe);
		}
		if ('access_token' in qres && typeof(qres.access_token) == 'string' &&
				qres.access_token.length > 0 && qres.access_token.length < 16384 &&
				'token_type' in qres && typeof(qres.token_type) == 'string' &&
				qres.token_type.length > 0 && qres.token_type.length < 32 &&
				'expires_in' in qres &&
				((typeof(qres.expires_in) == 'number' && !isNaN(qres.expires_in)) ||
				qres.expires_in == null) &&
				'refresh_token' in qres && typeof(qres.refresh_token) == 'string' &&
				qres.refresh_token.length > 0 && qres.refresh_token.length < 16384 &&
				'scope' in qres && typeof(qres.scope) == 'string' &&
				'created_at' in qres && typeof(qres.created_at) == 'number' &&
				!isNaN(qres.created_at) && qres.created_at > 0)
			return {access_token: qres.access_token, token_type: qres.token_type,
				expires_in: qres.expires_in, refresh_token: qres.refresh_token,
				scope: qres.scope, created_at: qres.created_at};
		return Promise.reject(new Error("Invalid response."));
	});
}

function outreachProspectsV1DropByStage(prospects, filterStageNames) {
	// As from https://api.outreach.io/1.0/prospects .
	var filteredProspects = [];
	prospects.forEach(function (prospect) {
		if (checkPathInDict(prospect, ["attributes", "stage", "name"]) &&
				typeof(prospect.attributes.stage.name) == "string" &&
				prospect.attributes.stage.name.length > 0 &&
				prospect.attributes.stage.name in filterStageNames) {
		} else {
			filteredProspects.push(prospect);
		}
	});
	return filteredProspects;
}

function outreachProspectsV2DropByStage(prospects, filterStageIds) {
	// As from https://api.outreach.io/api/v2/prospects .
	// Get ids from https://api.outreach.io/api/v2/stages .
	var filteredProspects = [];
	prospects.forEach(function (prospect) {
		if (checkPathInDict(prospect, ["relationships", "stage", "data", "type"]) &&
				prospect.relationships.stage.data.type == "stage" &&
				checkPathInDict(prospect, ["relationships", "stage", "data", "id"]) &&
				prospect.relationships.stage.data.id in filterStageIds) {
		} else {
			filteredProspects.push(prospect);
		}
	});
	return filteredProspects;
}

module.exports = exports = {dateConvertToOutreachUTC, outreachProspectV1ExtractAddress, outreachProspectsV1ExtractAddresses, outreachRecordsGet, outreachRecordPatch, outreachHeadersAppendToken, outreachRecordsGetAllWithToken, outreachTokenCheckValid, outreachTokenRefresh, outreachProspectsV1DropByStage, outreachProspectsV2DropByStage};

