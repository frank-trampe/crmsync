// Copyright 2017 by Frank Trampe
// This interfaces with services provided by Hubspot.
const frankenlib = require("frankenlib");
const requestp = require("request-promise-native");
function errPass(err) { return Promise.reject(err); }

function emailDomain(address) {
	return frankenlib.email_domain(address);
}

function arrayToDict(arrayData, keyName) {
	return frankenlib.array_to_dict(arrayData, keyName);
}

function dictToArray(dictData, keyName) {
	return frankenlib.dict_to_array(dictData, keyName);
}

function checkPathInDict(dict, dPath) {
	return frankenlib.check_path_in_dict(dict, dPath);
}

function makeQueryString(exso) {
	return frankenlib.make_query_string(exso);
}

function divideArray(flatArray, divisionSize) {
	return frankenlib.divide_array(flatArray, divisionSize);
}

function undivideArray(slicesArray) {
	return frankenlib.undivide_array(slicesArray);
}

function schedulePromise(opts, df) {
	if ("scheduler" in opts && opts.scheduler) {
		return opts.scheduler.schedule(df);
	}
	return Promise.resolve(df());
}

function hubspotContactsGetByAddress(emailList, opts) {
	// Page e-mail addresses so that we can fetch in bulk.
	var emailListBatched = divideArray(emailList, 40);
	var emailDispatches = [];
	// var emailFetches = [];
	// Dispatch the batches of contact fetches.
	emailListBatched.forEach(function (emailSlice) {
		emailDispatches.push(schedulePromise(opts, function () {
			var basePath = "https://api.hubapi.com/contacts/v1/contact/emails/batch/";
			var qps = {email: emailSlice};
			if ('hapikey' in opts && opts.hapikey) qps['hapikey'] = opts.hapikey;
			var queryParamsString = makeQueryString(qps);
			var hsFetch = requestp({
					uri: basePath + (queryParamsString.length ? "?" : "") + queryParamsString,
					method: "GET",
					simple: true,
					/* jar: cookie_jar, */
					encoding: null,
					resolveWithFullResponse: false /* Change to true to have the promise return the full response. */
			}).then(function (rd) {
				var qres = null;
				try {
					var rds = rd.toString("utf8");
					qres = JSON.parse(rds);
				} catch (rdpe) {
					return Promise.reject(rdpe);
				}
				if (qres && typeof(qres) == 'object')
					return qres; // It returns a dictionary of results keyed by vid.
				return null;
			}, errPass);
			return hsFetch;
			// emailFetches.push(hsFetch);
		}));
	});
	return Promise.all(emailDispatches);
	// return Promise.all(emailFetches);
}

function hubspotCompaniesGetByDomain(emailDomainList, opts) {
	var emailDomainDispatches = [];
	// var emailDomainFetches = [];
	emailDomainList.forEach(function (emailDomain) {
		emailDomainDispatches.push(schedulePromise(opts, function () {
			var emailDomainQueryPayload = {"requestOptions": {
				"properties": [
					"domain",
					"createdate",
					"name",
					"hs_lastmodifieddate",
					"lifecyclestage"
				]
			}};
			var basePath = "https://api.hubapi.com/companies/v2/domains/" + emailDomain + "/companies";
			var qps = {};
			if ('hapikey' in opts && opts.hapikey) qps['hapikey'] = opts.hapikey;
			var queryParamsString = makeQueryString(qps);
			var headers = {};
			headers['Content-Type'] = "application/json";
			var rpe = {
				uri: basePath + (queryParamsString.length ? "?" : "") + queryParamsString,
				method: "POST",
				body: emailDomainQueryPayload,
				simple: true,
				headers: headers,
				/* jar: cookie_jar, */
				json: true,
				encoding: null,
				resolveWithFullResponse: false /* Change to true to have the promise return the full response. */
			};
			var hsFetch = requestp(rpe).then(function (rd) {
				// Due to the dual-edged nature of the json option, the result is a parsed object.
				// console.log("Result.");
				// console.log(typeof(rd));
				// console.log(rd);
				var qres = null;
				if (0) {
					try {
						var rds = rd.toString("utf8");
						qres = JSON.parse(rds);
					} catch (rdpe) {
						return Promise.reject(rdpe);
					}
				} else {
					qres = rd;
				}
				if ('results' in qres && qres['results'] instanceof Array && qres['results'].length > 0) {
					return qres['results'][0];
					// if (qres['results'].length > 1) console.log("More than one matches for domain " + emailDomain + ".");
					// if (qres['results'].length > 0) return {emailDomain: emailDomain, companyRecord: qres['results'][0]};
				}
				return null;
			}, errPass);
			return hsFetch;
			// emailDomainFetches.push(hsFetch);
		}));
	});
	return Promise.all(emailDomainDispatches);
	// return Promise.all(emailDomainFetches);
}

function hubspotContactResultMakeAddressLookup(hsContactResults) {
	var hsContactLookup = {};
	hsContactResults.forEach(function (hsRecSet, hsRecSetI) {
		// We get a set of records from each query.
		if (hsRecSet) {
			var vidT;
			for (vidT in hsRecSet) {
				// Find the e-mail address.
				if (checkPathInDict(hsRecSet[vidT], ['properties', 'email', 'value']) &&
						typeof(hsRecSet[vidT].properties['email'].value) == 'string' &&
						hsRecSet[vidT].properties['email'].value.length > 0) {
					hsContactLookup[hsRecSet[vidT].properties['email'].value] = hsRecSet[vidT];
				}
			}
		}
	});
	return hsContactLookup;
}
function hubspotCompanyResultMakeDomainLookup(hsCompanyResults) {
	var hsCompanyLookup = {};
	hsCompanyResults.forEach(function (hsRecSet, hsRecSetI) {
		// We get a set of records from each query.
		if (hsRecSet) {
			hsRecSet.forEach(function (hsRec) {
				if (checkPathInDict(hsRec, ['properties', 'domain', 'value']) &&
						typeof(hsRec.properties['domain'].value) == 'string' &&
						hsRec.properties['domain'].value.length > 0) {
					hsCompanyLookup[hsRec.properties['domain'].value] = hsRec;
					// hsCompanyIdLookup[hsRec.companyId] = hsRec;
				}
			});
		}
	});
	return hsCompanyLookup;
}

function hubspotDataFetchForAddresses(emailList, opts) {
	// Dispatch the contact fetches.
	var bulkContactFetch = hubspotContactsGetByAddress(emailList, opts);
	// Dispatch the company fetches.
	var emailDomainList = frankenlib.email_domains(emailList);
	var bulkCompanyFetch = hubspotCompaniesGetByDomain(emailDomainList, opts);
	// Wait for all Hubspot results.
	return Promise.all([bulkContactFetch, bulkCompanyFetch]).then(
		function (hsResults) {
			if (hsResults[0] && hsResults[1]) {
				// We make lookups of the addresses and the company domains.
				var hsContactLookup = hubspotContactResultMakeAddressLookup(hsResults[0]);
				var hsCompanyLookup = hubspotCompanyResultMakeDomainLookup([hsResults[1]]);
				// If specified, we also get the contacts for the companies.
				if (opts && 'getCompanyContacts' in opts && opts.getCompanyContacts) {
					var hsCompanyContactLookup = {};
					var hsCompanyDomainTemp;
					var hsCompanyContactFetches = [];
					for (hsCompanyDomainTemp in hsCompanyLookup) {
						hsCompanyContactFetches.push(
							hubspotRecordsGetAll(opts, "GET", "https://api.hubapi.com/companies/v2/companies/" + hsCompanyLookup[hsCompanyDomainTemp].companyId + "/contacts", {hapikey: opts.hapikey}, "contacts")
							.then(function (companyContacts) {
								if (hsCompanyDomainTemp && companyContacts instanceof Array)
									return {domain: hsCompanyDomainTemp, contacts: companyContacts};
								return null;
							}, errPass)
						);
					}
					return Promise.all(hsCompanyContactFetches)
					.then(function (hsCompanyContacts) {
						hsCompanyContacts.forEach(function (companyContactBlock) {
							if (companyContactBlock && companyContactBlock.domain && companyContactBlock.contacts)
								hsCompanyContactLookup[companyContactBlock.domain] = companyContactBlock.contacts;
						});
						return {hsContactLookup: hsContactLookup, hsCompanyLookup: hsCompanyLookup, hsCompanyContactLookup, hsCompanyContactLookup};
					}, errPass);
				}
				return {hsContactLookup: hsContactLookup, hsCompanyLookup: hsCompanyLookup};
			}
			return Promise.reject(new Error("Hubspot lookups returned empty."));
		},
		errPass
	);	
}

	// check res.contact.email against hubspot
	// https://api.hubapi.com/contacts/v1/contact/emails/batch/?email=testingapis@hubspot.com&email=new-email@hubspot.com&hapikey=demo
	// check e-mail domain name against hubspot
	// POST hs_query_company_options to "https://api.hubapi.com/companies/v2/domains/" + emd + "/companies?hapikey=demo"
	// use res.results[0].companyId
	// TODO: Check whether searching for a company entity is sufficient or whether we need to search contacts.
	// https://api.hubapi.com/companies/v2/companies/10444744/contacts?hapikey=demo
	// use res.contacts[i].identities.vid to get the user ids
	// maybe perform a third fetch to get lifecycle stage
	// patch {data: {stage: {name: "Already in Hubspot"}}} to https://api.outreach.io/1.0/prospects/res.id


// This is what runs on Hubspot.
// get all company names from recently modified Hubspot contacts
// https://api.hubapi.com/contacts/v1/lists/recently_updated/contacts/recent?hapikey=demo&count=100
function hubspotRecordsGet(opts, method, basePath, queryParams, dataName, baseData, vidOffset) {
	var qps2 = {};
	for (qp in queryParams) qps2[qp] = queryParams[qp];
	if (vidOffset != null && vidOffset != undefined) qps2['vidOffset'] = vidOffset;
	var queryParamsString = makeQueryString(qps2);
	var rpe = {
		uri: basePath + (queryParamsString.length ? "?" : "") + queryParamsString,
		method: method,
		simple: true,
		/* jar: cookie_jar, */
		encoding: null,
		resolveWithFullResponse: false /* Change to true to have the promise return the full response. */
	};
	return schedulePromise(opts, function () { return requestp(rpe); })
	.then(function (rd) {
		var qres = null;
		try {
			var rds = rd.toString("utf8");
			qres = JSON.parse(rds);
		} catch (rdpe) {
			return Promise.reject(rdpe);
		}
		if (dataName in qres && qres[dataName] instanceof Array)
			baseData = baseData.concat(qres[dataName]);
		if (qres && 'has-more' in qres && qres['has-more'] && 'vid-offset' in qres && qres['vid-offset'] && (typeof(qres['vid-offset']) == 'string' && typeof(qres['vid-offset']) == 'number'))
			return hubspotRecordsGet(opts, method, basePath, queryParams, dataName, baseData, qres['vid-offset']);
		return baseData;
	}, errPass);
}

function hubspotRecordsGetAll(opts, method, basePath, queryParams, dataName) {
	return hubspotRecordsGet(opts, method, basePath, queryParams, dataName, [], null);
}

module.exports = exports = {hubspotContactsGetByAddress, hubspotCompaniesGetByDomain, hubspotContactResultMakeAddressLookup, hubspotCompanyResultMakeDomainLookup, hubspotDataFetchForAddresses, hubspotRecordsGet, hubspotRecordsGetAll};

